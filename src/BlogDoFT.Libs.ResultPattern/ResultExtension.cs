namespace BlogDoFT.Libs.ResultPattern;

public static class ResultExtension
{
    /// <summary>
    /// Executes the corresponding delegate depending on the success or failure state
    /// of the <paramref name="result"/>, returning a value of type <typeparamref name="TValue"/>.
    /// </summary>
    /// <typeparam name="TValue">The value type contained in the result.</typeparam>
    /// <param name="result">The result instance to inspect.</param>
    /// <param name="onSuccess">Executed when <paramref name="result"/> represents success.</param>
    /// <param name="onFailure">Executed when <paramref name="result"/> represents failure.</param>
    /// <returns>
    /// A value of type <typeparamref name="TValue"/> produced by the executed delegate.
    /// </returns>
    /// <remarks>
    /// Use this when you want to produce a final concrete value
    /// without continuing to compose additional results.
    /// </remarks>
    public static TValue On<TValue>(
        this Result<TValue> result,
        Func<TValue> onSuccess,
        Func<Failure, TValue> onFailure) =>
        result.IsSuccess ? onSuccess() : onFailure(result.Failure!);

    /// <summary>
    /// Maps a <see cref="Result{TValue}"/> into a value of type <typeparamref name="TReturn"/>,
    /// applying the appropriate function depending on whether it is a success or failure.
    /// </summary>
    /// <typeparam name="TValue">The type of the contained value when successful.</typeparam>
    /// <typeparam name="TReturn">The type returned by the mapping functions.</typeparam>
    /// <param name="result">The result to transform.</param>
    /// <param name="onSuccess">Function applied to the success value.</param>
    /// <param name="onFailure">Function applied to the failure value.</param>
    /// <returns>
    /// A value of type <typeparamref name="TReturn"/> generated by either delegate.
    /// </returns>
    /// <remarks>
    /// Useful for converting the inner success (or failure) value into a different type
    /// while preserving the semantics of success or failure.
    /// </remarks>
    public static TReturn Map<TValue, TReturn>(
        this Result<TValue> result,
        Func<TValue, TReturn> onSuccess,
        Func<Failure, TReturn> onFailure) =>
        result.IsSuccess ? onSuccess(result.Value!) : onFailure(result.Failure!);

    /// <summary>
    /// Maps a <see cref="Result{TValue}"/> into a value of type <typeparamref name="TReturn"/>,
    /// applying the appropriate function depending on whether it is a success or failure.
    /// </summary>
    /// <typeparam name="TValue">The type of the contained value when successful.</typeparam>
    /// <typeparam name="TReturn">The type returned by the mapping functions.</typeparam>
    /// <param name="task">The task result to transform.</param>
    /// <param name="onSuccess">Function applied to the success value.</param>
    /// <param name="onFailure">Function applied to the failure value.</param>
    /// <returns>
    /// A value of type <typeparamref name="TReturn"/> generated by either delegate.
    /// </returns>
    /// <remarks>
    /// Useful for converting the inner success (or failure) value into a different type
    /// while preserving the semantics of success or failure.
    /// </remarks>
    public static async Task<TReturn> MapAsync<TValue, TReturn>(
        this Task<Result<TValue>> task,
        Func<TValue, TReturn> onSuccess,
        Func<Failure, TReturn> onFailure)
    {
        var result = await task.ConfigureAwait(false);
        return result.IsSuccess
            ? onSuccess(result.Value!)
            : onFailure(result.Failure!);
    }

    /// <summary>
    /// Chains another operation that also returns <see cref="Result{T}"/>,
    /// automatically propagating the failure without invoking the next step.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="result">The current result instance.</param>
    /// <param name="next">The function that takes the success value and produces the next result.</param>
    /// <returns>
    /// The <see cref="Result{TOut}"/> produced by <paramref name="next"/> if successful,
    /// or the current failure otherwise.
    /// </returns>
    /// <remarks>
    /// This is the core monadic operation: it flattens chained results and
    /// prevents nested <c>if</c> or <c>try/catch</c> blocks.
    /// </remarks>
    public static Result<TOut> Then<TIn, TOut>(
        this Result<TIn> result,
        Func<TIn, Result<TOut>> next)
    {
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return next(result.Value!);
    }

    /// <summary>
    /// Asynchronous version of <see cref="Then{TIn, TOut}(Result{TIn}, Func{TIn, Result{TOut}})"/>
    /// for chaining tasks that produce <see cref="Result{T}"/>.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="task">The asynchronous operation producing a <see cref="Result{TIn}"/>.</param>
    /// <param name="next">
    /// An asynchronous function that takes the success value and produces a <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// representing either the next result or the propagated failure.
    /// </returns>
    /// <remarks>
    /// This allows composing async methods without losing the success/failure semantics.
    /// </remarks>
    public static async Task<Result<TOut>> ThenAsync<TIn, TOut>(
        this Task<Result<TIn>> task,
        Func<TIn, Task<Result<TOut>>> next)
    {
        var result = await task.ConfigureAwait(false);
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return await next(result.Value!).ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronous overload of <see cref="Then{TIn, TOut}(Result{TIn}, Func{TIn, Result{TOut}})"/>
    /// where the current result is synchronous but the next step is asynchronous.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="result">The current (synchronous) result.</param>
    /// <param name="next">
    /// An asynchronous function that takes the success value and produces a <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// either the computed result or the propagated failure.
    /// </returns>
    public static async Task<Result<TOut>> ThenAsync<TIn, TOut>(
        this Result<TIn> result,
        Func<TIn, Task<Result<TOut>>> next)
    {
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return await next(result.Value!).ConfigureAwait(false);
    }

    /// <summary>
    /// Convenience asynchronous overload where the current operation is asynchronous
    /// but the next function is synchronous.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="task">The asynchronous operation producing <see cref="Result{TIn}"/>.</param>
    /// <param name="next">
    /// A synchronous function that takes the success value and produces <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// either the computed result or the propagated failure.
    /// </returns>
    public static async Task<Result<TOut>> ThenAsync<TIn, TOut>(
        this Task<Result<TIn>> task,
        Func<TIn, Result<TOut>> next)
    {
        var result = await task.ConfigureAwait(false);
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return next(result.Value!);
    }

    /// <summary>
    /// Executes a side effect if the current <see cref="Result{T}"/> represents a failure,
    /// without modifying or replacing the result itself.
    /// </summary>
    /// <typeparam name="T">The type of the contained value when the result is successful.</typeparam>
    /// <param name="result">The result instance to inspect.</param>
    /// <param name="onFailure">
    /// The action to execute when the <paramref name="result"/> represents a failure.
    /// </param>
    /// <returns>
    /// The same <see cref="Result{T}"/> instance, allowing fluent chaining of operations.
    /// </returns>
    /// <remarks>
    /// Use this method to trigger notifications, logging, or other side effects
    /// when a failure occurs, while preserving the result pipeline intact.
    /// This method does not alter the original success or failure state.
    /// </remarks>
    public static Result<T> TapFailure<T>(this Result<T> result, Action<Failure> onFailure)
    {
        if (result.IsFailure)
        {
            onFailure(result.Failure);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect if the current <see cref="Result{T}"/> represents a failure,
    /// without modifying or replacing the result itself.
    /// </summary>
    /// <typeparam name="T">The type of the contained value when the result is successful.</typeparam>
    /// <param name="task">The asynchronous operation that produces a <see cref="Result{T}"/>.</param>
    /// <param name="onFailureAsync">
    /// The asynchronous function to execute when the <see cref="Result{T}"/> represents a failure.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to the same <see cref="Result{T}"/>,
    /// allowing fluent asynchronous chaining.
    /// </returns>
    /// <remarks>
    /// This method is useful for triggering asynchronous notifications, logging, or compensation actions
    /// when a failure occurs, without disrupting the original result pipeline.
    /// The returned <see cref="Result{T}"/> remains unchanged.
    /// </remarks>
    public static async Task<Result<T>> TapFailureAsync<T>(this Task<Result<T>> task, Func<Failure, Task> onFailureAsync)
    {
        var result = await task.ConfigureAwait(false);

        if (result.IsFailure)
        {
            await onFailureAsync(result.Failure).ConfigureAwait(false);
        }

        return result;
    }

    /// <summary>
    /// Executes an asynchronous side effect if the current <see cref="Result{T}"/> represents a failure,
    /// without modifying or replacing the result itself.
    /// </summary>
    /// <typeparam name="T">The type of the contained value when the result is successful.</typeparam>
    /// <param name="result">The current <see cref="Result{T}"/> instance.</param>
    /// <param name="onFailureAsync">
    /// The asynchronous function to execute when the <see cref="Result{T}"/> represents a failure.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to the same <see cref="Result{T}"/>,
    /// allowing fluent asynchronous chaining.
    /// </returns>
    /// <remarks>
    /// This overload is useful when you have a synchronous <see cref="Result{T}"/> in hand
    /// but need to perform an asynchronous action upon failure, such as logging or sending
    /// telemetry data to an external service.
    /// </remarks>
    public static async Task<Result<T>> TapFailureAsync<T>(this Result<T> result, Func<Failure, Task> onFailureAsync)
    {
        if (result.IsFailure)
        {
            await onFailureAsync(result.Failure).ConfigureAwait(false);
        }

        return result;
    }

    /// <summary>
    /// Executes a synchronous side effect if the awaited <see cref="Result{T}"/> represents a failure,
    /// without modifying or replacing the result itself.
    /// </summary>
    /// <typeparam name="T">The type of the contained value when the result is successful.</typeparam>
    /// <param name="task">The asynchronous operation producing a <see cref="Result{T}"/>.</param>
    /// <param name="onFailure">
    /// The synchronous action to execute when the <see cref="Result{T}"/> represents a failure.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to the same <see cref="Result{T}"/>,
    /// allowing fluent asynchronous chaining.
    /// </returns>
    /// <remarks>
    /// This overload avoids the need to return <see cref="Task.CompletedTask"/> when your failure handler is synchronous.
    /// </remarks>
    public static async Task<Result<T>> TapFailureAsync<T>(
        this Task<Result<T>> task,
        Action<Failure> onFailure)
    {
        var result = await task.ConfigureAwait(false);

        if (result.IsFailure)
        {
            onFailure(result.Failure);
        }

        return result;
    }
}
