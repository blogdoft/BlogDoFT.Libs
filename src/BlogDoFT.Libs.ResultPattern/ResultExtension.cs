namespace BlogDoFT.Libs.ResultPattern;

public static class ResultExtension
{
    /// <summary>
    /// Executes the corresponding delegate depending on the success or failure state
    /// of the <paramref name="result"/>, returning a value of type <typeparamref name="TValue"/>.
    /// </summary>
    /// <typeparam name="TValue">The value type contained in the result.</typeparam>
    /// <param name="result">The result instance to inspect.</param>
    /// <param name="onSuccess">Executed when <paramref name="result"/> represents success.</param>
    /// <param name="onFailure">Executed when <paramref name="result"/> represents failure.</param>
    /// <returns>
    /// A value of type <typeparamref name="TValue"/> produced by the executed delegate.
    /// </returns>
    /// <remarks>
    /// Use this when you want to produce a final concrete value
    /// without continuing to compose additional results.
    /// </remarks>
    public static TValue On<TValue>(
        this Result<TValue> result,
        Func<TValue> onSuccess,
        Func<Failure, TValue> onFailure) =>
        result.IsSuccess ? onSuccess() : onFailure(result.Failure!);

    /// <summary>
    /// Maps a <see cref="Result{TValue}"/> into a value of type <typeparamref name="TReturn"/>,
    /// applying the appropriate function depending on whether it is a success or failure.
    /// </summary>
    /// <typeparam name="TValue">The type of the contained value when successful.</typeparam>
    /// <typeparam name="TReturn">The type returned by the mapping functions.</typeparam>
    /// <param name="result">The result to transform.</param>
    /// <param name="onSuccess">Function applied to the success value.</param>
    /// <param name="onFailure">Function applied to the failure value.</param>
    /// <returns>
    /// A value of type <typeparamref name="TReturn"/> generated by either delegate.
    /// </returns>
    /// <remarks>
    /// Useful for converting the inner success (or failure) value into a different type
    /// while preserving the semantics of success or failure.
    /// </remarks>
    public static TReturn Map<TValue, TReturn>(
        this Result<TValue> result,
        Func<TValue, TReturn> onSuccess,
        Func<Failure, TReturn> onFailure) =>
        result.IsSuccess ? onSuccess(result.Value!) : onFailure(result.Failure!);

    /// <summary>
    /// Chains another operation that also returns <see cref="Result{T}"/>,
    /// automatically propagating the failure without invoking the next step.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="result">The current result instance.</param>
    /// <param name="next">The function that takes the success value and produces the next result.</param>
    /// <returns>
    /// The <see cref="Result{TOut}"/> produced by <paramref name="next"/> if successful,
    /// or the current failure otherwise.
    /// </returns>
    /// <remarks>
    /// This is the core monadic operation: it flattens chained results and
    /// prevents nested <c>if</c> or <c>try/catch</c> blocks.
    /// </remarks>
    public static Result<TOut> Bind<TIn, TOut>(
        this Result<TIn> result,
        Func<TIn, Result<TOut>> next)
    {
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return next(result.Value!);
    }

    /// <summary>
    /// Asynchronous version of <see cref="Bind{TIn, TOut}(Result{TIn}, Func{TIn, Result{TOut}})"/>
    /// for chaining tasks that produce <see cref="Result{T}"/>.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="task">The asynchronous operation producing a <see cref="Result{TIn}"/>.</param>
    /// <param name="next">
    /// An asynchronous function that takes the success value and produces a <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// representing either the next result or the propagated failure.
    /// </returns>
    /// <remarks>
    /// This allows composing async methods without losing the success/failure semantics.
    /// </remarks>
    public static async Task<Result<TOut>> BindAsync<TIn, TOut>(
        this Task<Result<TIn>> task,
        Func<TIn, Task<Result<TOut>>> next)
    {
        var result = await task.ConfigureAwait(false);
        if (result.IsFailure)
        {
            return result.Failure;
        }

        return await next(result.Value!).ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronous overload of <see cref="Bind{TIn, TOut}(Result{TIn}, Func{TIn, Result{TOut}})"/>
    /// where the current result is synchronous but the next step is asynchronous.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="result">The current (synchronous) result.</param>
    /// <param name="next">
    /// An asynchronous function that takes the success value and produces a <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// either the computed result or the propagated failure.
    /// </returns>
    public static async Task<Result<TOut>> BindAsync<TIn, TOut>(
        this Result<TIn> result,
        Func<TIn, Task<Result<TOut>>> next)
    {
        if (!result.IsSuccess)
        {
            return result.Failure;
        }

        return await next(result.Value!).ConfigureAwait(false);
    }

    /// <summary>
    /// Convenience asynchronous overload where the current operation is asynchronous
    /// but the next function is synchronous.
    /// </summary>
    /// <typeparam name="TIn">The input type of the current result.</typeparam>
    /// <typeparam name="TOut">The output type of the next result.</typeparam>
    /// <param name="task">The asynchronous operation producing <see cref="Result{TIn}"/>.</param>
    /// <param name="next">
    /// A synchronous function that takes the success value and produces <see cref="Result{TOut}"/>.
    /// </param>
    /// <returns>
    /// A <see cref="Task{TResult}"/> resolving to <see cref="Result{TOut}"/>,
    /// either the computed result or the propagated failure.
    /// </returns>
    public static async Task<Result<TOut>> BindAsync<TIn, TOut>(
        this Task<Result<TIn>> task,
        Func<TIn, Result<TOut>> next)
    {
        var result = await task.ConfigureAwait(false);
        if (!result.IsSuccess)
        {
            return result.Failure;
        }

        return next(result.Value!);
    }
}